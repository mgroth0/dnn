// Generated by CoffeeScript 2.5.1
var BinaryChoice_Base, BinaryChoice_Flash, BinaryChoice_Wait, Instruction, Login, Step, Thank_You, _current_step, _current_step_index, _steps, check_platform, fsHandler, push_data, push_data_async, run_step, run_steps, user,
  indexOf = [].indexOf;

_current_step_index = null;

_current_step = null;

_steps = null;

Step = class Step {
  constructor(save_after, controls) {
    this.save_after = save_after;
    this.controls = controls;
    this.readyForKey = false;
    this.finish_unixms = null;
    this.finished_data_push = false;
    this.last_step = null;
    this.is_last_trial = false;
  }

  run() {
    return log(`running ${this}`);
  }

  onkey(e) {}

  data() {
    var d;
    return d = {
      finish_unixms: this.finish_unixms
    };
  }

  finish() {
    var run_next, wait_timeout_recurse;
    this.finish_unixms = new Date().getTime();
    if (_current_step_index < _steps.length - 1) {
      id.prog.value += 1;
      id.top.style["justify-content"] = "center"; //so load indicator is centered
      run_next = () => {
        var wait_timeout_recurse;
        //                if @ instanceof
        if (this.is_last_trial) {
          push_data_async((t) => {
            return this.finished_data_push = true;
          });
          wait_timeout_recurse = () => {
            if (!this.finished_data_push) {
              log('waiting for data to push...');
              //                            id.loadIndicator.alternate(['/', '\\'], 1000)
              return setTimeout(() => {
                return wait_timeout_recurse();
              }, 100);
            } else {
              log('fading last trial loading indicator');
              return id.loadIndicator.fade(function() {
                log('faded last trial loading indicator');
                //                               id.loadIndicator.stop_alternating()
                id.top.style["justify-content"] = null;
                return run_step(_current_step_index + 1);
              });
            }
          };
          
          id.loadIndicator.unfade();
          return wait_timeout_recurse();
        } else {
          if (this.save_after) {
            push_data_async((t) => {
              return this.finished_data_push = true;
            });
          } else {
            this.finished_data_push = true;
          }
          return id.loadIndicator.fade(function() {
            //                        id.loadIndicator.stop_alternating()
            id.top.style["justify-content"] = null;
            return run_step(_current_step_index + 1);
          });
        }
      };
      if (this.last_step != null) {
        id.loadIndicator.unfade();
        wait_timeout_recurse = () => {
          if (!this.last_step.finished_data_push) {
            log('waiting for data to push...');
            //                        id.loadIndicator.alternate(['/', '\\'], 1000)
            return setTimeout(() => {
              return wait_timeout_recurse();
            }, 100);
          } else {
            return run_next();
          }
        };
        return wait_timeout_recurse();
      } else {
        return run_next();
      }
    }
  }

};

Instruction = class Instruction extends Step {
  constructor(text1, extra_id) {
    super(false, [SPACE_BAR]);
    this.text = text1;
    this.extra_id = extra_id;
  }

  run() {
    super.run();
    id.top.style['justify-content'] = 'center';
    if (this.extra_id == null) {
      //            apparently id isn't even needed since ids are auto-added to Window???????
      id['text-container'].style.height = '100%'; // so the text is centered
      id.text.style.height = '100%'; // so the text is centered
    } else {
      id['text-container'].style.height = null;
      id.text.style.height = null;
    }
    id['text-container'].unfade();
    id.text.style['text-align'] = 'left'; //best alignment for typing
    if (this.extra_id != null) {
      this.extra_id.appear(false, true);
      this.extra_id.op = 0;
    }
    return id.text.type(this.text.replace('TOKEN_VERSION', id.VERSION.innerHTML), () => {
      if (this.extra_id != null) {
        return this.extra_id.unfade(() => {
          return this.readyForKey = true;
        });
      } else {
        return this.readyForKey = true;
      }
    });
  }

  finish() {
    var ref;
    if ((ref = this.extra_id) != null) {
      ref.fade();
    }
    return id['text-container'].fade(() => {
      id.text.style['text-align'] = 'center'; //for trials
      return super.finish();
    });
  }

};

user = null;

Login = class Login extends Instruction {
  constructor(text) {
    var change_days;
    super(text, id.login);
    this.controls = [];
    this.save_after = true;
    //        FOR SAFARI
    //        if (id.birthday.type!="date"){ #if browser doesn't support input type="date", load files for jQuery UI Date Picker
    //            document.write('<link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/base/jquery-ui.css" rel="stylesheet" type="text/css" />\n')
    //            document.write('<script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"><\/script>\n')
    //        }
    //        if (id.birthday.type != "date") #if browser doesn't support input type="date", initialize date picker widget:
    //            $(document).ready(->

    //        nah, I want all browsers to act the same so I'll just override any native implementations
    //        $('#birthday').datepicker()

    //            )
    change_days = function() {
      var current_day, d, j, month, monthNum, node, num_days, ref, ref1, year;
      month = id.birthday_month.value;
      year = id.birthday_year.value;
      monthNum = new Date(Date.parse(month + " 1," + year)).getMonth() + 1;
      num_days = new Date(year, monthNum, 0).getDate();
      current_day = id.birthday_day.value;
      while (id.birthday_day.firstChild) {
        id.birthday_day.removeChild(id.birthday_day.lastChild);
      }
      for (d = j = 0, ref = num_days; (0 <= ref ? j <= ref : j >= ref); d = 0 <= ref ? ++j : --j) {
        node = document.createElement("OPTION");
        node.innerHTML = d.toString();
        id.birthday_day.appendChild(node);
      }
      if (ref1 = Number(current_day), indexOf.call((function() {
        var results = [];
        for (var k = 0; 0 <= num_days ? k <= num_days : k >= num_days; 0 <= num_days ? k++ : k--){ results.push(k); }
        return results;
      }).apply(this), ref1) >= 0) {
        return id.birthday_day.value = current_day;
      }
    };
    id.birthday_month.onchange = function() {
      return change_days();
    };
    id.birthday_year.onchange = function() {
      return change_days();
    };
    id.login_button.onclick = (e) => {
      user = {
        first_name: id.first_name.value.toUpperCase(),
        last_name: id.last_name.value.toUpperCase(),
        birthday: `${id.birthday_month.value}-${id.birthday_day.value}-${id.birthday_year.value}`
      };
      return this.finish();
    };
  }

  finish() {
    openFullscreen(tag.body);
    return super.finish();
  }

};

BinaryChoice_Base = class BinaryChoice_Base extends Step {
  constructor(im, t1, left_choice, right_choice) {
    super(false, [LEFT_ARROW, RIGHT_ARROW]);
    this.im = im;
    this.t = t1;
    this.left_choice = left_choice;
    this.right_choice = right_choice;
    this.choice = null;
    this.fix_path = true;
    this.presentation_time_unixms = null;
    this.reaction_time_ms = null;
  }

  run() {
    var RESOURCES_ROOT_REL;
    super.run();
    RESOURCES_ROOT_REL = id.RESOURCES_ROOT_REL.innerHTML;
    id.top.style["justify-content"] = "center"; // so the text and img is centered
    id['text-container'].disappear(); // so the img is centered
    //        id.text.innerHTML = center_str("#{@left_choice} <-?-> #{@right_choice}",'?')
    id.text.innerHTML = center_str(`${this.left_choice} <-?-> ${this.right_choice}`, '?');
    id['im-container'].appear();
    id.cross.appear();
    id.im.src = this.fix_path ? path_join(RESOURCES_ROOT_REL, this.im) : this.im;
    return this.display_stimulus();
  }

  display_stimulus() {
    throw 'abstract';
  }

  onkey(e) {
    this.reaction_time_ms = new Date().getTime() - this.presentation_time_unixms;
    return this.choice = ((e.keyCode === LEFT_ARROW.keyCode) ? this.left_choice : this.right_choice);
  }

  data() {
    return merge({im: this.im, t: this.t, choice: this.choice, reaction_time_ms: this.reaction_time_ms}, super.data());
  }

  finish() {
    id.im.disappear();
    id['im-container'].disappear();
    id['text-container'].disappear();
    //        id['text-container'].style.height = null
    //        id.text.style.height = null
    id.top.style["justify-content"] = null;
    return super.finish();
  }

};

BinaryChoice_Flash = class BinaryChoice_Flash extends BinaryChoice_Base {
  display_stimulus() {
    return setTimeout(() => {
      id.cross.disappear();
      setTimeout(() => {
        id.im.disappear();
        id['text-container'].style.height = '100%'; // so the text is centered
        id.text.style.height = '100%'; // so the text is centered
        id['text-container'].appear();
        return this.readyForKey = true;
      }, this.t);
      id.im.appear();
      return this.presentation_time_unixms = new Date().getTime();
    }, 1000);
  }

};

BinaryChoice_Wait = class BinaryChoice_Wait extends BinaryChoice_Base {
  display_stimulus() {
    return setTimeout(() => {
      id.cross.disappear();
      //            setTimeout(=>
      //                id.im.disappear()
      //                id.text.innerHTML = "#{@left_choice}<- ->#{@right_choice}"
      //                id['text-container'].style.height = '100%'
      //                id.text.style.height = '100%'
      //                id['text-container'].appear()
      //                @readyForKey = true
      //            , @t)
      //            id.top.style['justify-content'] = 'center' # so the text is above img
      id['text-container'].style.height = '10%'; // so the text is above img
      id.text.style.height = '10%'; // so the text is above img
      id['text-container'].appear();
      id.im.appear();
      this.presentation_time_unixms = new Date().getTime();
      return this.readyForKey = true;
    }, 1000);
  }

};

Thank_You = class Thank_You extends Instruction {
  constructor(text) {
    super(text, id.feedback);
    this.controls = [];
  }

};

//        dont need these any more since I prevented scrolling in the first place
//addEventListener("keydown", (e) ->
// prevent space and arrow keys from scrolling
//    if [32, 37, 38, 39, 40].indexOf(e.keyCode) > -1
//        e.preventDefault()
//, false)
keyup(function(e) {
  var ref;
  if ((_current_step != null) && (ref = e.keyCode, indexOf.call(_current_step.controls.map(function(c) {
    return c.keyCode;
  }), ref) >= 0)) {
    if (_current_step.readyForKey) {
      _current_step.readyForKey = false;
      _current_step.onkey(e);
      return _current_step.finish();
    }
  }
});

run_step = function(idx) {
  id['text-container'].fade();
  _current_step_index = idx;
  _current_step = _steps[_current_step_index];
  return _current_step.run();
};

check_platform = function(run_after) {
  var accepted_browsers, accepted_oss, browser, os;
  browser = platform.name;
  os = platform.os.family;
  accepted_browsers = ['Firefox', 'Safari', 'Chrome'];
  accepted_oss = ['OS X'];
  if (indexOf.call(accepted_browsers, browser) >= 0 && indexOf.call(accepted_oss, os) >= 0) {
    return run_after();
  } else {
    id.text.innerHTML = `Sorry, this experiment has not yet successfully passed tests on your platform (you are using ${os} and ${browser}). Please access this site using a supported operating system and browser: (Operating Systems: [${accepted_oss.join(',')}], Browsers: [${accepted_browsers.join(',')}]).`;
    id['top'].unfade();
    id['text-container'].unfade();
    return id['text'].unfade();
  }
};

run_steps = function(steps) {
  var i, j, ref;
  for (i = j = 1, ref = steps.length - 1; (1 <= ref ? j <= ref : j >= ref); i = 1 <= ref ? ++j : --j) {
    steps[i].last_step = steps[i - 1];
    if (steps[i] instanceof Thank_You) {
      steps[i - 1].is_last_trial = true;
    }
  }
  _steps = steps;
  id.prog.max = _steps.length - 1;
  id.top.unfade();
  return run_step(0);
};

push_data = function() {
  var data;
  data = {
    version: id.VERSION.innerHTML,
    steps: _steps.map(function(s) {
      return s.data();
    }),
    feedback: id.textarea.value
  };
  return new ExperimentDataBinAPI(inner.API_URL).push(user, data);
};

push_data_async = function(onFinish) {
  var data;
  data = {
    version: id.VERSION.innerHTML,
    steps: _steps.map(function(s) {
      return s.data();
    }),
    feedback: id.textarea.value
  };
  return new ExperimentDataBinAPI(inner.API_URL).push_async(user, data, onFinish);
};

id.button.addEventListener("click", function() {
  id.feedback_status.innerHTML = 'Please wait for data to upload...';
  return push_data_async(function() {
    return id.feedback_status.innerHTML = 'Feedback submitted, thank you!';
  });
});

fsHandler = function() {
  if (!window.IS_DEV_MODE) {
    if (document.webkitIsFullScreen || document.mozFullScreen || (document.msFullscreenElement === !null)) {
      id.top.appear();
      id['progress-container'].appear();
      return id.fullscreen_button.disappear();
    } else {
      id.top.disappear();
      id['progress-container'].disappear();
      return id.fullscreen_button.appear();
    }
  }
};

id['fullscreen_button'].onclick = function(e) {
  return openFullscreen(tag.body);
};

if (document.addEventListener) {
  document.addEventListener('fullscreenchange', fsHandler, false);
  document.addEventListener('mozfullscreenchange', fsHandler, false);
  document.addEventListener('MSFullscreenChange', fsHandler, false);
  document.addEventListener('webkitfullscreenchange', fsHandler, false);
}

//# sourceMappingURL=exp_lib.js.map
